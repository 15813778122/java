/**
  继承:继承是从已有的类创建新类的过程
    1.继承是面向对象三大特征之一
    2.被继承的类称为父类（超类），继承父类的类被称为子类（派生类）
    3.继承是指一个对象直接使用另一个对象的属性和方法
    4.通过继承可以实现代码重用
    
  继承一个父类，只能继承非私有的数据（属性和方法）
  protected访问权限修饰符，在继承关系中使用，在父类中使用protected修饰的属性或方法可以被子类继承
 
  创建子类对象时，父类的构造方法也会被调用，为什么？
  因为子类要使用到父类的数据，那么就要通过父类的构造方法来初始化数据
  如果创建子类对象时，会调用父类的默认构造方法

  当父类中没有无参构造方法时，子类必须显示的调用父类的带参构造方法，那么怎么调用呢？
  可以在子类中显示的使用super(...)调用父类的构造方法，只能出现在第一句

  继承的限制约定
    1.java只能实现单继承，也就是一个类只能有一个父类
    2.允许多层继承，即：一个子类可以有一个父类，一个父类还可以有其他的父类
    3.继承只能继承非私有的属性和方法
    4.构造方法不能被继承
 */

/**
  继承小结
    1.继承是发生在多个类之间
    2.继承使用关键字extends
    3.java只能单继承，允许多层继承
    4.被继承的类叫父类（超类），继承父类的类叫子类（派生类）
    5.在父类中的非私有属性和方法可以被子类继承
    6.protected（受保护的访问权限修饰符），修饰的属性或方法可以被子类继承
    7.构造方法不能被继承
    8.创建对象会调用构造方法，调用构造方法不一定就是创建该类对象
    9.实例化子类对象，会先调用父类的构造方法，如果父类中没有默认的构造方法，那么子类必须显示的通过super(...)来调用父类的带参构造方法，super也只能在子类构造方法中的第一句

  继承的好处：
    1.提高代码的复用性
    2.提高代码的维护性
    3.让类与类之间产生关系，是多态的前提

  继承的缺点：
    增强了类与类之前的耦合性
  
  开发原则：高内聚，低耦合
 */

/**
  在子类进行实例化操作的时候，首先会让其父类进行初始化操作，之后子类再自己进行实例化操作
  
  子类的实例化过程：
    子类实例化时先调用父类的构造方法
    如果父类中没有默认的构造方法，在子类的构造方法中必须显示的调用父类的构造方法
  
  结论：
  构造方法只是用于初始化类中的字段以及执行一些初始化代码
  调用构造方法并不代表会生成对象
 */

/**
  方法重写(overriding method)
  在java中，子类可继承父类中的方法，而不需要重写编写向相同的方法，但有时子类并不想原封不动地继承父类方法，而是想做一定的修改，这就需要采用方法的重写，方法重写又称为方法覆盖
  在子类和父类中，重写方法后，在调用时，以创建的对象类型为准，会调用谁的方法

  关于方法重写的一些特征
  1.发生在子父类中，方法重写的两个方法返回值，方法名，参数列表必须完全一致（子类重写父类的方法）
  2.子类抛出的异常不能超过父类相应方法抛出的异常（子类异常不能大于父类异常）
  3.子类方法的访问级别不能低于父类相应方法的访问级别（子类访问级别不能低于父类访问级别）
  4.父类中的方法若使用private，static，final任意修饰符修饰，那么，不能被子类重写

  为什么要重写方法？或者方法重写的目的是什么？
  若子类从父类中继承过来的方法，不能满足子类特有的需求时，子类就需要重写父类中相应的方法，方法的重写也是程序扩展的体现
 */

/**
  super关键字
  super可以完成以下操作：
    1.使用super调用父类的属性，可以从父类实例处获得信息
    2.使用super调用父类的方法，可以委托父类对象帮助完成某件事情。
    3.使用super调用父类中的构造方法（super(实参)形式），必须在子类构造方法的第一条语句，调用父类中相应的构造方法，若不显示的写出来，默认调用父类的无参构造方法，比如:super()

  this表示当前对象
  使用super来调用父类的属性，方法和构造方法
 */
public class Test1{
  public static void main(String[] args){
    HomeDog homeDog = new HomeDog("旺财");
    homeDog.print();
  }
}
class Dog{
  protected String name;
  private String sex;
  public Dog(String name,String sex){
    this.name = name;
    this.sex = sex;
    System.out.println("我是Dog的构造方法");
  }
  public void eat()throws Exception{
    System.out.println("吃饭");
  }
}
class HomeDog extends Dog{
  public HomeDog(String name){
    super(name,"公");
    System.out.println("我是HomeDog的构造方法");
  }
  public void print(){
    // super.属性 表示调用父类的属性，如果是继承过来的属性，那么super可以省略
    System.out.println(super.name+"我是一只家狗，wangwang");
  }
  public void eat()throws Exception{
    super.eat(); // 调用父类方法
    System.out.println("我是家狗，我要吃饭");
  }
}
class HuskyDog extends Dog{
  public void show(){
     super("husky","母");
    System.out.println(name+"husky会跳舞");
  }
   public void eat()throws Exception{
    System.out.println("我是哈士奇，我要吃狗粮");
  }
}